# -*- coding: utf-8 -*-
"""Edg Detection using Marr Hildreth Algo

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ddHHUsO0HCet0ted43eH0LlhlSwGFVUd
"""

import numpy as np
import cv2
from PIL import Image

img = cv2.imread('/content/n_n resized image.jpg')
img

import numpy as np
k1 = np.array([[-1, 0, 1],
               [-1, 0, 1],
               [-1, 0, 1]])

k2 = np.array([[-1, -1, -1],
               [0, 0, 0],
               [1, 1, 1]])
sigma = 0.6

matrix_operations = ((np.multiply(k1, k1) + np.multiply(k2, k2)) / (sigma ** 2))
laplacian = (1 / sigma ** 2) * (matrix_operations - 2)
gaussian = np.exp(-matrix_operations / 2)
final_kernal = np.multiply(laplacian, gaussian)
print(final_kernal)

def show_image(image):
  plt.figure(figsize=(8, 8))
  plt.axis('off')
  plt.imshow(image, cmap='gray')

from matplotlib import pyplot as plt
output= cv2.filter2D(src=img, ddepth=-1, kernel=final_kernal)




# -*- coding: utf-8 -*-
"""Edge Detection  using Laplacian Kernel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WoI7gnWlgNQbHDf3m8oyNkMTMj4JMFmK
"""

import numpy as np
import cv2
from PIL import Image

img = cv2.imread('/content/n_n resized image.jpg')
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
img

c = 255/(np.log(1 + np.max(img)))
log_transformed = c * np.log(1 + img)

log_transformed = np.array(log_transformed, dtype = np.uint8)

cv2.imwrite('log_transformed.jpg', log_transformed)

image = Image.fromarray(log_transformed)
image

image1 = Image.fromarray(img)
image1

import cv2
import numpy as np
import matplotlib.pyplot as plt

arr = np.full((100,100),100, dtype='uint8')
arr[50,40] = 200

image = cv2.imread('/content/log_transformed.jpg')
kernel = np.array([[-1, -1, -1],
                   [-1, 8, -1],
                   [-1, -1, -1]])
img = cv2.filter2D(image, -1 , kernel)
fig, ax = plt.subplots(1,2,figsize=(10,6))
ax[0].imshow(image)
ax[1].imshow(img)

plt.imshow(image, cmap = 'gray')

final = cv2.filter2D(arr, -1 , kernel)

plt.imshow(final, cmap = 'gray')



# -*- coding: utf-8 -*-
"""Numberofobjects.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NmWceBA2D6if-ZwhA0dGE0iK16UO2x4l
"""

from PIL import Image

im = Image.open('01grayscale.png','r').convert('L')

im

pix_val =np.array(im)

pix_val

imgsum = 0
length = 0
for i in pix_val:
    imgsum+= sum(i)
    length+=len(i)
print(imgsum)
print(length)

threshold = int(imgsum/length);

threshold

for i in range(len(pix_val)):
    for j in range(len(pix_val[i])):
        if pix_val[i][j]>threshold:
            pix_val[i][j]=255
        else:
            pix_val[i][j]=0

pix_val

new_image = Image.fromarray(pix_val)

#Black and White Image
new_image



# -*- coding: utf-8 -*-
"""kernals.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VyL91-YIJ7Gfl09L6cMS8d9aOyAzR7dJ
"""

pip install opencv-python

import cv2

image = cv2.imread('/content/greyscale.jpg')

image

gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

from matplotlib import pyplot as plt

plt.imshow(gray)
plt.show()

import numpy as np

convolution_kernel1 = np.array([[-1, -2, -1], 
                    [0 , 0, 0], 
                    [1, 2, 1]])

result1 = cv2.filter2D(gray, -1, convolution_kernel1)

result1

plt.imshow(result1)

convolution_kernel2 = np.array([[-1, 0, 1], 
                    [-2 , 0, 2], 
                    [-1, 0, 1]])

result2 = cv2.filter2D(gray, -1, convolution_kernel2)

plt.imshow(result2)

result = result1+result2

plt.imshow(result)

plt.imshow(gray+result)












show_image(img)
show_image(output)
